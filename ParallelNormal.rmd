---
title: "Parallel MCMC"
output: html_document
date: "2022-08-11"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
devtools::load_all()
require(ape)
require(parallel)
```

## Normal random variables, unknown mean

data $X_1, X_2, \dots, X_n \stackrel{i.i.d.}{\sim} N(\theta, \sigma^2)$, known variance $\sigma^2$, unknown mean $\theta$.

Normal prior $\theta \sim N(\mu, \tau^2)$, proposals $\theta^* \sim N(\theta^{(n)}, s^2)$

Acceptance probabilities
\[
\alpha(\theta^* , \theta) = \min \left\{ 1, \exp \left\{ - \frac{1}{2 \tilde{\sigma}^2} ({\theta^* }^2 - 2 \tilde{\mu} (\theta^* - \theta) - \theta^2) \right\} \right\},
\]
log-acceptance probabilities
\[
\alpha_{\log} (\theta^* | \theta) = \min \left\{ 0, - \frac{1}{2 \tilde{\sigma}^2} ({\theta^* }^2 - 2 \tilde{\mu} (\theta^* - \theta) - \theta^2) \right\}
\]
for
\[
\tilde{\sigma}^2 = \left( \frac{n}{\sigma^2} + \frac{1}{\tau^2} \right)^{-1} \qquad \tilde{\mu}  = \tilde{\sigma}^2 \left( \frac{n\bar{X}}{\sigma^2} + \frac{\mu}{\tau^2} \right).
\]


### Data generation
```{r}
set.seed(1234)
n <- 100
true_mean <- 0  #"Unknown" data mean
data_sd <- 1  #Known data standard deviation
data <- rnorm(n, mean = true_mean, sd = data_sd)
prior_mean <- 0
prior_sd <- 1/sqrt(2)

N <- 1e6
prop_sd <- 10 #Proposal standard deviation
```

### Unparallelised

```{r}
last_est <- mean(data)  #Initialise estimate for theta at mean of data

post_var <- 1/(n/(data_sd^2) + 1/(prior_sd^2))
post_mean <- post_var * (sum(data) / (data_sd^2) + prior_mean/(prior_sd^2))

#### Main MCMC Run
sample <- numeric(N)
proposals <- matrix(0, nrow = N, ncol = 2)  #Store all proposals in col 1, indicator in col 2 for acceptance

non_parallel_time <- system.time({
  for (i in 1 : N){
    proposals[i,1] <- rnorm(1, mean = last_est, sd = prop_sd)
    accept_prob <- min(0, - (proposals[i,1]^2 - 2 * post_mean * (proposals[i,1] - last_est) - last_est^2)/(2 * post_var))
    
    if (log(runif(1)) <= accept_prob){  #Accept proposal
      last_est <- proposals[i,1]
      proposals[i,2] <- 1
    }
    
    sample[i] <- last_est
  }
})
hist(sample, probability = TRUE)
x <- seq(-10,10,0.01)
lines(dnorm(x, mean = post_mean, sd = sqrt(post_var)) ~ x, lty = 2)
abline(v = post_mean, col = "red")
abline(v = mean(sample), col = "blue")
legend("topright", legend = c("Posterior Mean", "MCMC sample Mean", "Posterior Density"), lty = c(1,1,2), col = c("red", "blue", "black"))

thinned <- seq.int(1,N, 1001)
accepted <- thinned[which(proposals[thinned,2] == 0)]
plot(sample, type = 'l', ylim = c(-2,2))
points(proposals[accepted,1] ~ accepted, col = "azure3")

accept_rate <- 1 - sum(proposals[,2] == 0)/N

print(non_parallel_time)
print(accept_rate)
```

### Non-parallel sapply

```{r}
last_est <- mean(data)  #Initialise estimate for theta at mean of data

post_var <- 1/(n/(data_sd^2) + 1/(prior_sd^2))
post_mean <- post_var * (sum(data) / (data_sd^2) + prior_mean/(prior_sd^2))

proposal_func <- function(iter){
  prop <- rnorm(1, mean = last_est, sd = prop_sd)
  accept_prob <- min(0, - (prop^2 - 2 * post_mean * (prop - last_est) - last_est^2)/(2 * post_var))
  
  if (log(U[iter]) < accept_prob){
    return(list(proposal = prop, accept = TRUE))
  } else{
    return(list(proposal = prop, accept = FALSE))
  }
}

#### Main MCMC Run
sample <- numeric(N)
proposals <- matrix(0, nrow = N, ncol = 2)  #Store all proposals in col 1, indicator in col 2 for acceptance
iteration <- 1

non_parallel_sapply_time <- system.time({
  while (iteration < N){
    k9 <- 100
    U <- runif(k9)
    props <- lapply(1:k9, proposal_func)
    accepted <- sapply(1:k9, function(x){props[[x]]$accept})
    first_accepted <- min(which(accepted == TRUE), 8)
    
    if (iteration + first_accepted <= N){
      proposals[iteration + 1:first_accepted - 1, 1] <- sapply(1:first_accepted, function(x){props[[x]]$proposal})
      sample[iteration + 1:first_accepted - 1] <- last_est
      
      if (props[[first_accepted]]$accept){
        sample[iteration + first_accepted - 1] <- last_est <- props[[first_accepted]]$proposal
        proposals[iteration + first_accepted - 1, 2] <- 1
      }
      
      iteration <- iteration + first_accepted
    } else {
      proposals[iteration:N, 1] <- sapply(1:(N - iteration + 1), function(x){props[[x]]$proposal})
      sample[iteration:N] <- last_est
    }
  }
})

hist(sample, probability = TRUE)
x <- seq(-10,10,0.01)
lines(dnorm(x, mean = post_mean, sd = sqrt(post_var)) ~ x, lty = 2)
abline(v = post_mean, col = "red")
abline(v = mean(sample), col = "blue")
legend("topright", legend = c("Posterior Mean", "MCMC sample Mean", "Posterior Density"), lty = c(1,1,2), col = c("red", "blue", "black"))

thinned <- seq.int(1,N, 1001)
accepted <- thinned[which(proposals[thinned,2] == 0)]
plot(sample, type = 'l', ylim = c(-2,2))
points(proposals[accepted,1] ~ accepted, col = "azure3")

accept_rate <- 1 - sum(proposals[,2] == 0)/N

print(non_parallel_sapply_time)
print(accept_rate)

```

### Parallelised

```{r}
N <- 1e3
no_cores <- 4
# for (no_cores in 1 : 8){
prop_sd <- 10 #Proposal standard deviation
last_est <- mean(data)  #Initialise estimate for theta at mean of data

post_var <- 1/(n/(data_sd^2) + 1/(prior_sd^2))
post_mean <- post_var * (sum(data) / (data_sd^2) + prior_mean/(prior_sd^2))

proposal_func <- function(iter){
  prop <- rnorm(1, mean = last_est, sd = prop_sd)
  accept_prob <- min(0, - (prop^2 - 2 * post_mean * (prop - last_est) - last_est^2)/(2 * post_var))
  
  if (log(U[iter]) < accept_prob){
    return(list(proposal = prop, accept = TRUE))
  } else{
    return(list(proposal = prop, accept = FALSE))
  }
}

#### Main MCMC Run
sample <- numeric(N)
proposals <- matrix(0, nrow = N, ncol = 2)  #Store all proposals in col 1, indicator in col 2 for acceptance
iteration <- 1

parallel_time <- system.time({
  while (iteration < N){
    k2 <- 100
    U <- runif(k2)
    props <- mclapply(1:k2, proposal_func, mc.cores = no_cores)
    accepted <- sapply(1:k2, function(x){props[[x]]$accept})
    first_accepted <- min(which(accepted == TRUE), 8)
    
    if (iteration + first_accepted <= N){
      proposals[iteration + 1:first_accepted - 1, 1] <- sapply(1:first_accepted, function(x){props[[x]]$proposal})
      sample[iteration + 1:first_accepted - 1] <- last_est
      
      if (props[[first_accepted]]$accept){
        sample[iteration + first_accepted - 1] <- last_est <- props[[first_accepted]]$proposal
        proposals[iteration + first_accepted - 1, 2] <- 1
      }
      
      iteration <- iteration + first_accepted
    } else {
      proposals[iteration:N, 1] <- sapply(1:(N - iteration + 1), function(x){props[[x]]$proposal})
      sample[iteration:N] <- last_est
    }
  }
})

hist(sample, probability = TRUE)
x <- seq(-10,10,0.01)
lines(dnorm(x, mean = post_mean, sd = sqrt(post_var)) ~ x, lty = 2)
abline(v = post_mean, col = "red")
abline(v = mean(sample), col = "blue")
legend("topright", legend = c("Posterior Mean", "MCMC sample Mean", "Posterior Density"), lty = c(1,1,2), col = c("red", "blue", "black"))

thinned <- seq.int(1,N, 1001)
accepted <- thinned[which(proposals[thinned,2] == 0)]
plot(sample, type = 'l', ylim = c(-2,2))
points(proposals[accepted,1] ~ accepted, col = "azure3")

accept_rate <- 1 - sum(proposals[,2] == 0)/N
print(accept_rate)
print(parallel_time)
# k_core_par_time[[no_cores]] <- parallel_time
# }
```

### Sapply with delay

Check the MCMC with "slow proposals" - compare to parallel with slow proposals to check when parallel better than serial (due to parallelisation overhead)

```{r}
N <- 1e3
last_est <- mean(data)  #Initialise estimate for theta at mean of data

post_var <- 1/(n/(data_sd^2) + 1/(prior_sd^2))
post_mean <- post_var * (sum(data) / (data_sd^2) + prior_mean/(prior_sd^2))

delays <- 0:10/1000
non_par_delay_time <- list()


for (i in 1 : length(delays)){
  set.seed(1234)
  delay <- delays[i]
  
  slow_prop <- function(iter){
    prop <- rnorm(1, mean = last_est, sd = prop_sd)
    accept_prob <- min(0, - (prop^2 - 2 * post_mean * (prop - last_est) - last_est^2)/(2 * post_var))
    Sys.sleep(delay)
    
    if (log(U[iter]) < accept_prob){
      return(list(proposal = prop, accept = TRUE))
    } else{
      return(list(proposal = prop, accept = FALSE))
    }
  }
  
  #### Main MCMC Run
  sample <- numeric(N)
  proposals <- matrix(0, nrow = N, ncol = 2)  #Store all proposals in col 1, indicator in col 2 for acceptance
  iteration <- 1
  
  non_par_delay_time[[i]] <- system.time({
    while (iteration < N){
      U <- runif(8)
      props <- lapply(1:8, slow_prop)
      accepted <- sapply(1:8, function(x){props[[x]]$accept})
      first_accepted <- min(which(accepted == TRUE), 8)
      
      if (iteration + first_accepted <= N){
        proposals[iteration + 1:first_accepted - 1, 1] <- sapply(1:first_accepted, function(x){props[[x]]$proposal})
        sample[iteration + 1:first_accepted - 1] <- last_est
        
        if (props[[first_accepted]]$accept){
          sample[iteration + first_accepted - 1] <- last_est <- props[[first_accepted]]$proposal
          proposals[iteration + first_accepted - 1, 2] <- 1
        }
        
        iteration <- iteration + first_accepted
      } else {
        proposals[iteration:N, 1] <- sapply(1:(N - iteration + 1), function(x){props[[x]]$proposal})
        sample[iteration:N] <- last_est
      }
    }
  })
}
non_par_delay_time
plot(delays, sapply(1:length(delays), function(x) non_par_delay_time[[x]][3]))
```

### Mclapply with delay

```{r}
N <- 1e3
options(mc.cores=8)
last_est <- mean(data)  #Initialise estimate for theta at mean of data

post_var <- 1/(n/(data_sd^2) + 1/(prior_sd^2))
post_mean <- post_var * (sum(data) / (data_sd^2) + prior_mean/(prior_sd^2))

reps <- 5
delays <- sort(rep(0:20/1000, reps))
par_delay_time <- list()


pb <- txtProgressBar(min = 0, max = length(delays), initial = 0, style = 3) #Load progress bar (max = N for "finished" condition)

for (i in 1 : length(delays)){
  set.seed(1234)
  delay <- delays[i]
  
  slow_prop <- function(iter){
    prop <- rnorm(1, mean = last_est, sd = prop_sd)
    accept_prob <- min(0, - (prop^2 - 2 * post_mean * (prop - last_est) - last_est^2)/(2 * post_var))
    Sys.sleep(delay)
    
    if (log(U[iter]) < accept_prob){
      return(list(proposal = prop, accept = TRUE))
    } else{
      return(list(proposal = prop, accept = FALSE))
    }
  }
  
  #### Main MCMC Run
  sample <- numeric(N)
  proposals <- matrix(0, nrow = N, ncol = 2)  #Store all proposals in col 1, indicator in col 2 for acceptance
  iteration <- 1
  
  par_delay_time[[i]] <- system.time({
    while (iteration < N){
      U <- runif(8)
      props <- mclapply(1:8, slow_prop)
      accepted <- sapply(1:8, function(x){props[[x]]$accept})
      first_accepted <- min(which(accepted == TRUE), 8)
      
      if (iteration + first_accepted <= N){
        proposals[iteration + 1:first_accepted - 1, 1] <- sapply(1:first_accepted, function(x){props[[x]]$proposal})
        sample[iteration + 1:first_accepted - 1] <- last_est
        
        if (props[[first_accepted]]$accept){
          sample[iteration + first_accepted - 1] <- last_est <- props[[first_accepted]]$proposal
          proposals[iteration + first_accepted - 1, 2] <- 1
        }
        
        iteration <- iteration + first_accepted
      } else {
        proposals[iteration:N, 1] <- sapply(1:(N - iteration + 1), function(x){props[[x]]$proposal})
        sample[iteration:N] <- last_est
      }
    }
  })
  
  setTxtProgressBar(pb, i)
}

close(pb) #Close progress bar outside of loop at end

par_delay_time
plot(delays, sapply(1:length(delays), function(x) par_delay_time[[x]][3]), ylim = c(0, 1.1 * max(sapply(1:length(delays), function(x) par_delay_time[[x]][3]))), xlab = "delay", ylab = "Elapsed time")
#points(delays, sapply(1:length(delays), function(x) non_par_delay_time[[x]][3]), col = "azure3")
abline(lm(sapply(1:length(delays), function(x) par_delay_time[[x]][3]) ~ delays))
x <- 0:10/1000
abline(lm(sapply(1:length(x), function(x) non_par_delay_time[[x]][3]) ~ x), col = "azure3")
#points(delays, sapply(1:length(delays), function(x) non_par_delay_time[[x]][3]), col = "azure3")
```
